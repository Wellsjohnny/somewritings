#+SETUPFILE: ./../etc/org_mode_SETUPFILE.org
#+TITLE: Gradle Introdução
#+SUBTITLE: intermediario

* Introdução
  

* Instalação do Gradle e Conf do Path  
  
  Faça o download do gradle em 
  https://downloads.gradle.org/distributions/gradle-5.5-rc-4-bin.zip
  
  Descompacte em o gradle em algum diretório, eu descompactei o meu em
  
  /home/wagner/wagnerdocri@gmail.com3/fzlbpms/fzlStudio/integrated/build/gradle-5.1.1

  Agora crie a variável de ambiente GRADLE_HOME e configure o PATH da
  sua máquina.

  #+NAME: export env vars
  #+BEGIN_SRC shell :results output :exports both
     export GRADLE_HOME=/home/wagner/wagnerdocri@gmail.com3/fzlbpms/fzlStudio/integrated/build/gradle-5.1.1
     export PATH=$PATH:$GRADLE_HOME/bin     
     gradle -v
  #+END_SRC

  #+RESULTS:
  #+begin_example

  ------------------------------------------------------------
  Gradle 5.1.1
  ------------------------------------------------------------

  Build time:   2019-01-10 23:05:02 UTC
  Revision:     3c9abb645fb83932c44e8610642393ad62116807

  Kotlin DSL:   1.1.1
  Kotlin:       1.3.11
  Groovy:       2.5.4
  Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018
  JVM:          1.8.0_191 (Oracle Corporation 25.191-b12)
  OS:           Linux 5.1.18-200.fc29.x86_64 amd64

  #+end_example


* Criação de um projeto java básico
  https://guides.gradle.org/building-java-applications/

  Pra criar um projeto com gradle a gente cria uma pasta, entra nela e
  dá o comando gradle init + parametros.
  Esse "init" é um plugin do gradle[gradleCodsInitPlugin]
  
   #+NAME: criac proj java                    
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      export GRADLE_PROJECTS_DIR=/home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/                                 
      mkdir -p $GRADLE_PROJECTS_DIR
      
      cd $GRADLE_PROJECTS_DIR
      rm -rf demojavaproj
      mkdir demojavaproj && cd demojavaproj
      echo 1 | gradle init --type java-application \
                  --project-name demojavaproject \
                  --package br.com.exemplo \
                  --test-framework junit #\
                  #-Dhttp.proxyHost=192.168.0.2 -Dhttp.proxyPort=3128 -Dhttp.proxyUser=cid2 -Dhttp.proxyPort=cid2                  
      pwd
      ls -la
   #+END_SRC

   #+RESULTS:
   #+begin_example

   [wagner@Unknown demojavaproj]$ [wagner@Unknown demojavaproj]$ [wagner@Unknown demojavaproj]$ [wagner@Unknown projetos]$ [wagner@Unknown projetos]$ [wagner@Unknown demojavaproj]$ > > > Starting a Gradle Daemon (subsequent builds will be faster)
   Task :wrapper
   Task :init

   BUILD SUCCESSFUL in 3s
   2 actionable tasks: 2 executed
   [wagner@Unknown demojavaproj]$ /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj
   total 44
   drwxrwxr-x. 5 wagner wagner 4096 jul 21 21:05 .
   drwxrwxr-x. 4 wagner wagner 4096 jul 21 21:05 ..
   -rw-rw-r--. 1 wagner wagner  949 jul 21 21:05 build.gradle
   -rw-rw-r--. 1 wagner wagner  103 jul 21 21:05 .gitignore
   drwxrwxr-x. 4 wagner wagner 4096 jul 21 21:05 .gradle
   drwxrwxr-x. 3 wagner wagner 4096 jul 21 21:05 gradle
   -rwxrwxr-x. 1 wagner wagner 5305 jul 21 21:05 gradlew
   -rw-rw-r--. 1 wagner wagner 2269 jul 21 21:05 gradlew.bat
   -rw-rw-r--. 1 wagner wagner  363 jul 21 21:05 settings.gradle
   drwxrwxr-x. 4 wagner wagner 4096 jul 21 21:05 src
   #+end_example

   Nos comandos acima, o mais importante foi gradle init que pode ser
   dado também com o gradle --task :init


* Conhecendo a estrutura do nosso projeto   
  
  Segue abaixo a estrutura do projeto. O importante é conhecer pra que
  que serve cada um arquivo e diretório, o professor vai ler com vcs em sala de aula e
  explicar cada um desses arquivos.
  

** O arquivo build.gradle

     #+BEGIN_src groovy
 /*
 ,* This file was generated by the Gradle 'init' task.
 ,*
 ,* This generated file contains a sample Java project to get you started.
 ,* For more details take a look at the Java Quickstart chapter in the Gradle
 ,* user guide available at https://docs.gradle.org/5.1.1/userguide/tutorial_java_projects.html
 ,*/

plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Apply the application plugin to add support for building an application
    id 'application'
}

repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

dependencies {
    // This dependency is found on compile classpath of this component and consumers.
    implementation 'com.google.guava:guava:26.0-jre'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}

// Define the main class for the application
mainClassName = 'br.com.exemplo.App'
     #+END_src


** O arquivo .gitignore

   Se o seu projeto não tiver um, pode criar.
   O professore vai explicar em sala sobre esse arquivo.



** O diretório .gradle


** O diretório  gradle

     Diretório de cache do gradle


** O arquivo gradlew

     Um shellscript pra usar o o comando gradlew (gradle wrapper) no
     linux

** O arquivo gradlew.bat 

     Arquivo de lote pra usar o comando gradlew (gradle wrapper) no
     windows


** settings.gradle
   
   Esse é o arquivo que a gente mais vai utilizar durante as aulas
   #+include: /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/settings.gradle  :src groovy


** src

   Diretório dos nossos códigos
     
** src/main/java/br/com/exemplo/App.java
   codigo java (src/main/java/br/com/exemplo/App.java)

   #+include: ~/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/src/main/java/br/com/exemplo/App.java :src java
   
** src/test/java/br/com/exemplo/AppTest.java
   codigo java (src/test/java/br/com/exemplo/AppTest.java)
   #+include: ~/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/src/test/java/br/com/exemplo/AppTest.java :src java


* Buildando e Executando o projeto

  Entre escrever um código e rodá-lo, precisa gerar os bytecodes
  (buildar) empacotar.
  Pra efeitos do nosso projetinho de exemplo, empacotar significa
  gerar um arquivo jar que possa ser executável.
  Não vai pensar que é todo jar que é executável heinn... Você vai
  lembrar que vários jars servem apenas como bibliotecas, lembra?
  Então um jar pra ser executável mesmo vc precisar configuar no
  MANIFEST.mf qual a
  classe que tem o método main. Agente vai ver isso daqui a pouco.
  
  Bom, pelo código java dá pra perceber que a funcionalidade dele é
  emitir uma saudação, e a classe de teste testa  se a
  saudação não é nula.

  
   #+NAME: arquivo properties                    
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      #cd $GRADLE_PROJECTS_DIR/demojavaproj
      #echo "org.gradle.daemon=true" > gradle.properties
      #echo "org.gradle.parallel=true" >> gradle.properties
   #+END_SRC

   #+RESULTS:

  
   #+NAME: buildando o projeto                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj && ./gradlew build
   #+END_SRC


   #+NAME: gradle tasks
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj && ./gradlew tasks
   #+END_SRC


   #+BEGIN_EXAMPLE
   [wagner@Unknown gradle-introduction]$ gradle -v

------------------------------------------------------------
Gradle 5.1.1
------------------------------------------------------------

Build time:   2019-01-10 23:05:02 UTC
Revision:     3c9abb645fb83932c44e8610642393ad62116807

Kotlin DSL:   1.1.1
Kotlin:       1.3.11
Groovy:       2.5.4
Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018
JVM:          1.8.0_201 (Oracle Corporation 25.201-b09)
OS:           Linux 4.20.5-200.fc29.x86_64 amd64

[wagner@Unknown gradle-introduction]$ gradle build
Starting a Gradle Daemon, 1 incompatible Daemon could not be reused, use --status for details

> Task :buildEnvironment

------------------------------------------------------------
Root project
------------------------------------------------------------

classpath
No dependencies

A web-based, searchable dependency report is available by adding the --scan option.

BUILD SUCCESSFUL in 4s
1 actionable task: 1 executed
[wagner@Unknown gradle-introduction]$ 

   #+END_EXAMPLE

   
   Mas a gente faz o build pra que mesmo? A resposta é: pra obter o
   nosso projeto como um pacote, ou seja, um arquivo só que pode ser
   utilizado. A maioria das pessoas já pensa num arquivo .exe mas o
   java pode gerar vários tipos de arquivos inclusive um executável
   embora a extensão não seja exe mas .jar, isso mesmo um arquivo
   executável com a extensão .jar
   Um jar pode ser um arquivo executável ou não, se a gente quer que
   ele seja a gente configura o arquivo MANIFEST dele pra que ele seja e se a
   gente não quer que ele seja executável a gente não configura.
   É muito comum que um arquivo jar não seja executável. As
   dependencias dos nossos projetos java, e vc vai lembrar quando a
   gente trabalha com jdbc, por exemplo, que tem que usar a
   dependencia jdbc do banco que é um jar.. aquele jar do jdbc não era
   executável. Aquele jar do jdbc nada mais era que código java empacotado que serve pra gente usar nos
   nossos projetos.
   Se vc não entendeu isso o professor escalarece pra vc na sala de
   aula.
   Então a gente deu um gradle build e ele deve então ter gerado o
   nosso projeto como um pacote certo? Vamos ver...

   #+NAME: avaliando build1                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj
      ls -l 
      ls -l build
      ls -l build/distributions
   #+END_SRC

   #+RESULTS:
   #+begin_example

   [wagner@Unknown demojavaproj]$ total 32
   drwxrwxr-x. 9 wagner wagner 4096 fev  3 14:21 build
   -rw-rw-r--. 1 wagner wagner  949 fev  3 14:16 build.gradle
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:16 gradle
   -rwxrwxr-x. 1 wagner wagner 5305 fev  3 14:16 gradlew
   -rw-rw-r--. 1 wagner wagner 2269 fev  3 14:16 gradlew.bat
   -rw-rw-r--. 1 wagner wagner  363 fev  3 14:16 settings.gradle
   drwxrwxr-x. 4 wagner wagner 4096 fev  3 14:16 src
   total 28
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:21 classes
   drwxrwxr-x. 2 wagner wagner 4096 fev  3 14:21 distributions
   drwxrwxr-x. 2 wagner wagner 4096 fev  3 14:21 libs
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:21 reports
   drwxrwxr-x. 2 wagner wagner 4096 fev  3 14:21 scripts
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:21 test-results
   drwxrwxr-x. 5 wagner wagner 4096 fev  3 14:21 tmp
   total 5488
   -rw-rw-r--. 1 wagner wagner 3000320 fev  3 14:21 demojavaproject.tar
   -rw-rw-r--. 1 wagner wagner 2615429 fev  3 14:21 demojavaproject.zip
   #+end_example

   Acima a gente vê o resultado do nosso build. É um diretório chamado
   build que dentro dele tem as compilação das classes java dentre
   outros artefatos resultantes do build.
   No diretório build/distributions tem o nosso projeto empacotado
   como .tar e como .zip
   O arquivo .tar é mais comumente utilizado no linux, e o zip com
   certeza vc já conhece.
   

   
   #+NAME:  build1 Descompact
   #+BEGIN_SRC sh :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj/build/distributions            
      unzip demojavaproject.zip 2>&1
      cd demojavaproject
      ls -l
      ls -l bin
      cd bin
      pwd
      cd ..
      ls -l lib
   #+END_SRC

   #+RESULTS:
   #+begin_example

   [wagner@Unknown distributions]$ Archive:  demojavaproject.zip
      creating: demojavaproject/
      creating: demojavaproject/lib/
     inflating: demojavaproject/lib/demojavaproject.jar  
     inflating: demojavaproject/lib/guava-26.0-jre.jar  
     inflating: demojavaproject/lib/jsr305-3.0.2.jar  
     inflating: demojavaproject/lib/checker-qual-2.5.2.jar  
     inflating: demojavaproject/lib/error_prone_annotations-2.1.3.jar  
     inflating: demojavaproject/lib/j2objc-annotations-1.1.jar  
     inflating: demojavaproject/lib/animal-sniffer-annotations-1.14.jar  
      creating: demojavaproject/bin/
     inflating: demojavaproject/bin/demojavaproject  
     inflating: demojavaproject/bin/demojavaproject.bat
   [wagner@Unknown demojavaproject]$ total 8
   drwxr-xr-x. 2 wagner wagner 4096 fev  3 15:22 bin
   drwxr-xr-x. 2 wagner wagner 4096 fev  3 15:22 lib
   total 12
   -rwxr-xr-x. 1 wagner wagner 5504 fev  3 15:22 demojavaproject
   -rwxr-xr-x. 1 wagner wagner 2496 fev  3 15:22 demojavaproject.bat
   [wagner@Unknown bin]$ /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/build/distributions/demojavaproject/bin
   [wagner@Unknown demojavaproject]$ total 2928
   -rw-rw-r--. 1 wagner wagner    3482 jan  5 22:51 animal-sniffer-annotations-1.14.jar
   -rw-rw-r--. 1 wagner wagner  193322 fev  3 13:10 checker-qual-2.5.2.jar
   -rw-rw-r--. 1 wagner wagner    1064 fev  3 15:22 demojavaproject.jar
   -rw-rw-r--. 1 wagner wagner   13704 fev  3 13:10 error_prone_annotations-2.1.3.jar
   -rw-rw-r--. 1 wagner wagner 2740721 fev  3 13:10 guava-26.0-jre.jar
   -rw-rw-r--. 1 wagner wagner    8764 jan  5 22:51 j2objc-annotations-1.1.jar
   -rw-rw-r--. 1 wagner wagner   19936 fev  3 13:10 jsr305-3.0.2.jar
   #+end_example


   Pessoal, vamos lá compreender nosso build...
   Unzipei o projeto que gerou uma pasta do proje com o diretório bin
   e o diretório lib
   O diretório bin tem dois arquivos um bat e ouhtro pra executar no
   linux.
   A pasta lib tem alguns jars de que nosso projeto depende e muito
   interessante tem o demojavaproject.jar
   Cada um deles, obviamente, tem sua razão de estar alí. Não vou
   entrar em cada um mas vou passar uns links...

   + jsr305-3.0.2.jar

     Disponibiliza anotações para qualidade de código
     https://www.infoq.com/news/2008/06/jsr-305-update
     https://www.youtube.com/watch?v=J2fgb8nWUo8
     
   + animal-sniffer-annotations-1.14.jar

     Útil qdo vc tem código de uma versão do java que precisa rodar em
     uma versão diferente que sem o animal-siffer seria incompatível.
     https://www.baeldung.com/maven-animal-sniffer

   + checker-qual-2.5.2.jar

     Ferramenta de qualidade de código
     https://checkerframework.org/manual/#installation
     
   + demojavaproject.jar
     Esse é o jar do nosso projeto. Infelizmente o gradle não
     configurou ele pra ser um executável, conforme demostra o código
     abaixo.
     Entretanto, o gradle te dá maneiras que, a meu veu, eles acham
     que é mais prática pra executar o seu projeto que são os arquivos
     executáveis que a gente já viu anteriormente neste texto.
   #+NAME: run jar                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj/build/distributions/demojavaproject/lib
      java -jar demojavaproject.jar
   #+END_SRC

   #+RESULTS:
   : 
   : [wagner@Unknown lib]$ nenhum atributo de manifesto principal em demojavaproject.jar

   + error_prone_annotations-2.1.3.jar
     Análise estática do código pra melhora da qualidade. Tem um
     exemplo fácil de entendem em https://github.com/google/error-prone


   + guava-26.0-jre.jar
     Esse jar é uma biblioteca do criada pela google pra facilitar
     algumas tarefas em java com collections etc.
     Esse link abaixo mostra como se configura ela no seu projeto    
     https://github.com/google/guava/wiki/UseGuavaInYourBuild

     
   + j2objc-annotations-1.1.jar
     Esse é o site do projeto desse jar:
     https://developers.google.com/j2objc/
     A utilidade desse jar é transformar código java em código
     objective-C atraves de seus comandos. Como a gente não vai
     desenvolver pra IOS não vamos usar essa biblioteca na prática.

   

   Vamos dar uma olhada nos arquivos do diretório bin primeiro, o .bat
   Abaixo segue o arquivo, parece meio complicadinho mas a gente não
   vei editar ele pra nada, a gente só vai usar pra executar nosso
   programa. Se tiver curiosidade, dá uma olhada nele depois.
   
   Agora o outro pra ser executado no linux
   Mesma coisa, vc não precisa entender shellscript pra executar ele
   certo? No futuro estude shellscript que vale a pena...   Depois vc
   pode dar uma olhada nele também.

** Executando o nosso programa   
   Bom vamos executar nosso programa então...
   
   #+NAME: exec prog                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj/build/distributions/demojavaproject/bin
      ./demojavaproject
   #+END_SRC

   #+RESULTS:
   : 
   : [wagner@Unknown bin]$ Hello world.

   Executando esse arquivo dá pra perceber que o programa foi
   executado.


   To me sentindo culpado por não ter rodado o teste antes, mas
   eis aí.. Na nossa disciplina sobre qualidade de software vcs vão
   entender o por quê?
   
   #+NAME: rod teste                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj
      ./gradlew test
   #+END_SRC
   
   #+BEGIN_EXAMPLE
   [wagner@Unknown demojavaproj]$ ./gradlew test
> Task :compileJava UP-TO-DATE
> Task :processResources NO-SOURCE
> Task :classes UP-TO-DATE
> Task :compileTestJava UP-TO-DATE
> Task :processTestResources NO-SOURCE
> Task :testClasses UP-TO-DATE
> Task :test UP-TO-DATE

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 up-to-date
[wagner@Unknown demojavaproj]$ 
   #+END_EXAMPLE

   Claro que a gente vai escrever muitos testes na nossa disciplina,
   neste momento a agente apenas rodou esse né... daqui a pouco a
   gente vai estudar e modifcar esse teste.

   Tem um relatório dos testes em html, vamos ver?


   
   #+NAME: test reports                   
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      firefox /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/build/reports/tests/test/index.html
   #+END_SRC

   #+RESULTS: test reports


* Fluxo de trabalho dom o gradle   
  Quando vc tiver trabalhando com o seu projeto que usa gradle as taks
  que vc usará em geral são;
  gradle clean, pra limpar tudo que tiver sido construído
  gradle build pra buildar
  gradle test pra testar
  gradle run pra rodar 
  gradle distZip pra gerar um zip do projeto 


* Tasks do gradle
  
  O que vem depois do gradle... o clean o init o build etc... são
  tasks do gradle
  
  O comando gradle tasks mostra as tasks que estão disponíveis pra vc
  utilizar.
  
  
   #+NAME: example gralde tasks                    
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      [wagner@Unknown demojavaproj]$ gradle tasks

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------

Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Distribution tasks
------------------
assembleDist - Assembles the main distributions
distTar - Bundles the project as a distribution.
distZip - Bundles the project as a distribution.
installDist - Installs the project as a distribution as-is.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project 'demojavaproject'.
components - Displays the components produced by root project 'demojavaproject'. [incubating]
dependencies - Displays all dependencies declared in root project 'demojavaproject'.
dependencyInsight - Displays the insight into a specific dependency in root project 'demojavaproject'.
dependentComponents - Displays the dependent components of components in root project 'demojavaproject'. [incubating]
help - Displays a help message.
model - Displays the configuration model of root project 'demojavaproject'. [incubating]
projects - Displays the sub-projects of root project 'demojavaproject'.
properties - Displays the properties of root project 'demojavaproject'.
tasks - Displays the tasks runnable from root project 'demojavaproject'.

Verification tasks
------------------
check - Runs all checks.
test - Runs the unit tests.

Rules
-----
Pattern: clean<TaskName>: Cleans the output files of a task.
Pattern: build<ConfigurationName>: Assembles the artifacts of a configuration.
Pattern: upload<ConfigurationName>: Assembles and uploads the artifacts belonging to a configuration.

To see all tasks and more detail, run gradle tasks --all

To see more detail about a task, run gradle help --task <task>

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
[wagner@Unknown demojavaproj]$ 

   #+END_SRC
  
Tem bastante né? Com o tempo a gente vai se acostumando com as
funcionalidades de cada uma. A verdade é que elas é que salvam a
patria qdo vc tiver enroscado com alguma questão específica do seu
projeto. Isso vai acontecer quando vc tiver trabalhando na área...


* Referencias
  tarfileWikiPedia https://pt.wikipedia.org/wiki/Tar_(computa%C3%A7%C3%A3o)
  gradleCodsInitPlugin https://docs.gradle.org/current/userguide/build_init_plugin.html
  http://professorramos.com/index.php/script-bat-2-como-criar-um-menu-em-arquivos-bat/
