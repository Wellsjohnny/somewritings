#+SETUPFILE: ./../etc/org_mode_SETUPFILE.org
#+TITLE: Gradle: Introdução
#+SUBTITLE: intermediario

* Instalação do Gradle e Conf do Path  

  #+NAME export env vars
  #+BEGIN_SRC shell :results output :exports both
     export GRADLE_HOME=/home/wagner/wagnerdocri@gmail.com3/fzlbpms/fzlStudio/integrated/build/gradle-5.1.1
     export PATH=$PATH:$GRADLE_HOME/bin     
     gradle -v
  #+END_SRC

  #+RESULTS:
  #+begin_example

  ------------------------------------------------------------
  Gradle 5.1.1
  ------------------------------------------------------------

  Build time:   2019-01-10 23:05:02 UTC
  Revision:     3c9abb645fb83932c44e8610642393ad62116807

  Kotlin DSL:   1.1.1
  Kotlin:       1.3.11
  Groovy:       2.5.4
  Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018
  JVM:          1.8.0_191 (Oracle Corporation 25.191-b12)
  OS:           Linux 4.20.5-200.fc29.x86_64 amd64

  #+end_example


* Criação de um projeto java básico
  https://guides.gradle.org/building-java-applications/

  Pra criar um projeto com gradle a gente cria uma pasta, entra nela e
  dá o comando gradle init + parametros.
  Esse "init" é um plugin do gradle[gradleCodsInitPlugin]
  
   #+NAME criac proj java                    
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      export GRADLE_PROJECTS_DIR=/home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/                                 
      mkdir -p $GRADLE_PROJECTS_DIR
      
      cd $GRADLE_PROJECTS_DIR
      rm -rf demojavaproj
      mkdir demojavaproj && cd demojavaproj
      echo 1 | gradle init --type java-application \
                  --project-name demojavaproject \
                  --package br.com.exemplo \
                  --test-framework junit #\
                  #-Dhttp.proxyHost=192.168.0.2 -Dhttp.proxyPort=3128 -Dhttp.proxyUser=cid2 -Dhttp.proxyPort=cid2
                  
      pwd
      ls -l
   #+END_SRC

   #+RESULTS:
   #+begin_example

   [wagner@Unknown gradle-introduction]$ [wagner@Unknown gradle-introduction]$ [wagner@Unknown gradle-introduction]$ [wagner@Unknown gradle-introduction]$ [wagner@Unknown projetos]$ [wagner@Unknown projetos]$ [wagner@Unknown demojavaproj]$ > > > > Task :wrapper
   Task :init

   BUILD SUCCESSFUL in 0s
   2 actionable tasks: 2 executed
   /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj
   total 28
   -rw-rw-r--. 1 wagner wagner  949 fev  3 14:16 build.gradle
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:16 gradle
   -rwxrwxr-x. 1 wagner wagner 5305 fev  3 14:16 gradlew
   -rw-rw-r--. 1 wagner wagner 2269 fev  3 14:16 gradlew.bat
   -rw-rw-r--. 1 wagner wagner  363 fev  3 14:16 settings.gradle
   drwxrwxr-x. 4 wagner wagner 4096 fev  3 14:16 src
   #+end_example

   Nos comandos acima, o mais importante foi gradle init que pode ser
   dado também com o gradle --task :init


* Conhecendo a estrutura do projeto   
  
  Segue abaixo a estrutura do projeto. O importante conhecer pra que
  que serve cada um, o professor vai ler com vcs em sala de aula e
  explicar cada um desses arquivos.
  

   + build.gradle
     #+BEGIN_src groovy
/*
 ,* This file was generated by the Gradle 'init' task.
 ,*
 ,* This generated file contains a sample Java project to get you started.
 ,* For more details take a look at the Java Quickstart chapter in the Gradle
 ,* user guide available at https://docs.gradle.org/5.1.1/userguide/tutorial_java_projects.html
 ,*/

plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Apply the application plugin to add support for building an application
    id 'application'
}

repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

dependencies {
    // This dependency is found on compile classpath of this component and consumers.
    implementation 'com.google.guava:guava:26.0-jre'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}

// Define the main class for the application
mainClassName = 'br.com.exemplo.App'
     #+END_src


   + .gitignore
     #+BEGIN_src groovy
# Ignore Gradle project-specific cache directory
.gradle

# Ignore Gradle build output directory
build
     #+END_src


   + .gradle


   + gradle

     Diretório de cache do gradle


   + gradlew

     Um shellscript pra usar o o comando gradlew (gradle wrapper) no
     linux


   + gradlew.bat

     Arquivo de lote pra usar o comando gradlew (gradle wrapper) no
     windows


   + settings.gradle

     #+include: /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/settings.gradle  :src groovy


   + src

     diretório de código 
     
   + codigo java (src/main/java/br/com/exemplo/App.java)

     #+include: ~/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/src/main/java/br/com/exemplo/App.java :src java
   
   + codigo java (src/test/java/br/com/exemplo/AppTest.java)
     #+include: ~/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/src/test/java/br/com/exemplo/AppTest.java :src java

* Buildando e Executando o projeto
  Pessoal, vcs precisam lembrar que o código não roda do jeito que tá,
  precisa gerar os bytecodes empacotar pra depois rodar.
  Então pra rodar tem que: buildar, e empacotar.
  Pra efeitos do nosso projetinho de exemplo, empacotar significa
  gerar um arquivo jar que possa ser executável.
  Vai vai pensar que é todo jar que é executável heinn, pra ser ele
  precisa de ter uma método main e uma configuraçãozinha sobre
  isso. Agente vai ver isso daqui a pouco.
  
  Bom, pelo código java dá pra perceber que a funcionalidade dele é
  emitir uma saudação, e a classe de teste testa exatamente isso, se a
  saudação não é nula.

  
   #+NAME arquivo properties                    
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      #cd $GRADLE_PROJECTS_DIR/demojavaproj
      #echo "org.gradle.daemon=true" > gradle.properties
      #echo "org.gradle.parallel=true" >> gradle.properties
   #+END_SRC

   #+RESULTS:

  
   #+NAME buildando o projeto                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj && gradle build
   #+END_SRC


   #+BEGIN_EXAMPLE
   [wagner@Unknown gradle-introduction]$ gradle -v

------------------------------------------------------------
Gradle 5.1.1
------------------------------------------------------------

Build time:   2019-01-10 23:05:02 UTC
Revision:     3c9abb645fb83932c44e8610642393ad62116807

Kotlin DSL:   1.1.1
Kotlin:       1.3.11
Groovy:       2.5.4
Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018
JVM:          1.8.0_201 (Oracle Corporation 25.201-b09)
OS:           Linux 4.20.5-200.fc29.x86_64 amd64

[wagner@Unknown gradle-introduction]$ gradle build
Starting a Gradle Daemon, 1 incompatible Daemon could not be reused, use --status for details

> Task :buildEnvironment

------------------------------------------------------------
Root project
------------------------------------------------------------

classpath
No dependencies

A web-based, searchable dependency report is available by adding the --scan option.

BUILD SUCCESSFUL in 4s
1 actionable task: 1 executed
[wagner@Unknown gradle-introduction]$ 

   #+END_EXAMPLE

   
   Mas a gente faz o build pra que mesmo? A resposta é: pra obter o
   nosso projeto como um pacote, ou seja, um arquivo só que pode ser
   utilizado. A maioria das pessoas já pensa num arquivo .exe mas o
   java pode gerar vários tipos de arquivos inclusive um executável
   embora a extensão não seja exe mas .jar, isso mesmo um arquivo
   executável com a extensão .jar
   Um jar pode ser um arquivo executável ou não, se a gente quer que
   ele seja a gente configura o MANIFEST dele pra que ele seja e se a
   gente não quer que ele seja executável a gente não configura.
   É muito comum que um arquivo jar não seja executável. As
   dependencias dos nossos projetos java, e vc vai lembrar quando a
   gente trabalha com jdbc, por exemplo, que tem que usar a
   dependencia jdbc do banco que é um jar.. esse jar não é
   executável. É código java empacotado que serve pra gente usar nos
   nossos projetos e nesse caso não é executável já que a gente quer
   somente usar as classes desse jar no nosso projeto que aí sim pode
   ser configurado como um jar executável.
   Se vc não entendeu isso o professor escalarece pra vc na sala de
   aula.
   Então a gente deu um gradle build e ele deve então ter gerado o
   nosso projeto como um pacote certo? Vamos ver...

   #+NAME avaliando build1                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj
      ls -l 
      ls -l build
      ls -l build/distributions
   #+END_SRC

   #+RESULTS:
   #+begin_example

   [wagner@Unknown demojavaproj]$ total 32
   drwxrwxr-x. 9 wagner wagner 4096 fev  3 14:21 build
   -rw-rw-r--. 1 wagner wagner  949 fev  3 14:16 build.gradle
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:16 gradle
   -rwxrwxr-x. 1 wagner wagner 5305 fev  3 14:16 gradlew
   -rw-rw-r--. 1 wagner wagner 2269 fev  3 14:16 gradlew.bat
   -rw-rw-r--. 1 wagner wagner  363 fev  3 14:16 settings.gradle
   drwxrwxr-x. 4 wagner wagner 4096 fev  3 14:16 src
   total 28
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:21 classes
   drwxrwxr-x. 2 wagner wagner 4096 fev  3 14:21 distributions
   drwxrwxr-x. 2 wagner wagner 4096 fev  3 14:21 libs
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:21 reports
   drwxrwxr-x. 2 wagner wagner 4096 fev  3 14:21 scripts
   drwxrwxr-x. 3 wagner wagner 4096 fev  3 14:21 test-results
   drwxrwxr-x. 5 wagner wagner 4096 fev  3 14:21 tmp
   total 5488
   -rw-rw-r--. 1 wagner wagner 3000320 fev  3 14:21 demojavaproject.tar
   -rw-rw-r--. 1 wagner wagner 2615429 fev  3 14:21 demojavaproject.zip
   #+end_example

   Acima a gente vê o resultado do nosso build. É um diretório chamado
   build que dentro dele tem as compilação das classes java dentre
   outros artefatos resultantes do build.
   No diretório build/distributions tem o nosso projeto empacotado
   como .tar e como .zip
   O arquivo .tar é mais comumente utilizado no linux, e o zip com
   certeza vc já conhece.
   

   
   #+NAME  build1 Descompact
   #+BEGIN_SRC sh :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj/build/distributions            
      unzip demojavaproject.zip 2>&1
      cd demojavaproject
      ls -l
      ls -l bin
      cd bin
      pwd
      cd ..
      ls -l lib
   #+END_SRC

   #+RESULTS:
   #+begin_example

   [wagner@Unknown distributions]$ Archive:  demojavaproject.zip
      creating: demojavaproject/
      creating: demojavaproject/lib/
     inflating: demojavaproject/lib/demojavaproject.jar  
     inflating: demojavaproject/lib/guava-26.0-jre.jar  
     inflating: demojavaproject/lib/jsr305-3.0.2.jar  
     inflating: demojavaproject/lib/checker-qual-2.5.2.jar  
     inflating: demojavaproject/lib/error_prone_annotations-2.1.3.jar  
     inflating: demojavaproject/lib/j2objc-annotations-1.1.jar  
     inflating: demojavaproject/lib/animal-sniffer-annotations-1.14.jar  
      creating: demojavaproject/bin/
     inflating: demojavaproject/bin/demojavaproject  
     inflating: demojavaproject/bin/demojavaproject.bat
   [wagner@Unknown demojavaproject]$ total 8
   drwxr-xr-x. 2 wagner wagner 4096 fev  3 15:22 bin
   drwxr-xr-x. 2 wagner wagner 4096 fev  3 15:22 lib
   total 12
   -rwxr-xr-x. 1 wagner wagner 5504 fev  3 15:22 demojavaproject
   -rwxr-xr-x. 1 wagner wagner 2496 fev  3 15:22 demojavaproject.bat
   [wagner@Unknown bin]$ /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/build/distributions/demojavaproject/bin
   [wagner@Unknown demojavaproject]$ total 2928
   -rw-rw-r--. 1 wagner wagner    3482 jan  5 22:51 animal-sniffer-annotations-1.14.jar
   -rw-rw-r--. 1 wagner wagner  193322 fev  3 13:10 checker-qual-2.5.2.jar
   -rw-rw-r--. 1 wagner wagner    1064 fev  3 15:22 demojavaproject.jar
   -rw-rw-r--. 1 wagner wagner   13704 fev  3 13:10 error_prone_annotations-2.1.3.jar
   -rw-rw-r--. 1 wagner wagner 2740721 fev  3 13:10 guava-26.0-jre.jar
   -rw-rw-r--. 1 wagner wagner    8764 jan  5 22:51 j2objc-annotations-1.1.jar
   -rw-rw-r--. 1 wagner wagner   19936 fev  3 13:10 jsr305-3.0.2.jar
   #+end_example


   Pessoal, vamos lá compreender nosso build...
   Unzipei o projeto que gerou uma pasta do proje com o diretório bin
   e o diretório lib
   O diretório bin tem dois arquivos um bat e ouhtro pra executar no
   linux.
   A pasta lib tem alguns jars de que nosso projeto depende e muito
   interessante tem o demojavaproject.jar
   Cada um deles, obviamente, tem sua razão de estar alí. Não vou
   entrar em cada um mas vou passar uns links...

   + jsr305-3.0.2.jar

     Disponibiliza anotações para qualidade de código
     https://www.infoq.com/news/2008/06/jsr-305-update
     https://www.youtube.com/watch?v=J2fgb8nWUo8
     
   + animal-sniffer-annotations-1.14.jar

     Útil qdo vc tem código de uma versão do java que precisa rodar em
     uma versão diferente que sem o animal-siffer seria incompatível.
     https://www.baeldung.com/maven-animal-sniffer

   + checker-qual-2.5.2.jar

     Ferramenta de qualidade de código
     https://checkerframework.org/manual/#installation
     
   + demojavaproject.jar
     Esse é o jar do nosso projeto. Infelizmente o gradle não
     configurou ele pra ser um executável, conforme demostra o código
     abaixo.
     Entretanto, o gradle te dá maneiras que, a meu veu, eles acham
     que é mais prática pra executar o seu projeto que são os arquivos
     executáveis que a gente já viu anteriormente neste texto.
   #+NAME run jar                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj/build/distributions/demojavaproject/lib
      java -jar demojavaproject.jar
   #+END_SRC

   #+RESULTS:
   : 
   : [wagner@Unknown lib]$ nenhum atributo de manifesto principal em demojavaproject.jar

   + error_prone_annotations-2.1.3.jar
     Análise estática do código pra melhora da qualidade. Tem um
     exemplo fácil de entendem em https://github.com/google/error-prone


   + guava-26.0-jre.jar

   + j2objc-annotations-1.1.jar


   
   
   Vamos dar uma olhada nos arquivos do diretório bin primeiro, o .bat
   Abaixo segue o arquivo, parece meio complicadinho mas a gente não
   vei editar ele pra nada, a gente só vai usar pra executar nosso programa
   #+INCLUDE: /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/build/distributions/demojavaproject/bin/demojavaproject.bat :src bat
   
   Agora o outro pra ser executado no linux
   Mesma coisa, vc não precisa entender shellscript pra executar ele
   certo? No futuro estude shellscript que vale a pena...   
   #+INCLUDE: /home/wagner/wagnerdocri@gmail.com3/envs/env-dev/sources/somewritings/gradle-introduction/projetos/demojavaproj/build/distributions/demojavaproject/bin/demojavaproject :src shell
   
   Bom vamos executar nosso programa então...
   
   #+NAME exec prog                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj/build/distributions/demojavaproject/bin
      ./demojavaproject
   #+END_SRC

   #+RESULTS:
   : 
   : [wagner@Unknown bin]$ Hello world.

   Executando esse arquivo dá pra perceber que o programa foi
   executado.


   To me sentindo meio culpado por não ter rodado o teste antes, mas
   eis aí..
   
   #+NAME rod teste                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      cd $GRADLE_PROJECTS_DIR/demojavaproj
      gradle test
   #+END_SRC
   
* Fluxo de trabalho dom o gradle   
  Quando vc tiver trabalhando com o seu projeto que usa gradle as taks
  que vc usará em geral são;
  gradle clean, pra limpar tudo que tiver sido construído
  gradle build pra buildar
  gradle test pra testar
  gradle run pra rodar 
  gradle distZip pra gerar um zip do projeto 

* Tasks do gradle
  
  O que vem depois do gradle... o clean o init o build etc... são
  tasks do gradle
  
  O comando gradle tasks mostra as tasks que estão disponíveis pra vc
  utilizar.
  
  
   #+NAME example gralde tasks                    
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      [wagner@Unknown demojavaproj]$ gradle tasks

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------

Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Distribution tasks
------------------
assembleDist - Assembles the main distributions
distTar - Bundles the project as a distribution.
distZip - Bundles the project as a distribution.
installDist - Installs the project as a distribution as-is.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project 'demojavaproject'.
components - Displays the components produced by root project 'demojavaproject'. [incubating]
dependencies - Displays all dependencies declared in root project 'demojavaproject'.
dependencyInsight - Displays the insight into a specific dependency in root project 'demojavaproject'.
dependentComponents - Displays the dependent components of components in root project 'demojavaproject'. [incubating]
help - Displays a help message.
model - Displays the configuration model of root project 'demojavaproject'. [incubating]
projects - Displays the sub-projects of root project 'demojavaproject'.
properties - Displays the properties of root project 'demojavaproject'.
tasks - Displays the tasks runnable from root project 'demojavaproject'.

Verification tasks
------------------
check - Runs all checks.
test - Runs the unit tests.

Rules
-----
Pattern: clean<TaskName>: Cleans the output files of a task.
Pattern: build<ConfigurationName>: Assembles the artifacts of a configuration.
Pattern: upload<ConfigurationName>: Assembles and uploads the artifacts belonging to a configuration.

To see all tasks and more detail, run gradle tasks --all

To see more detail about a task, run gradle help --task <task>

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
[wagner@Unknown demojavaproj]$ 

   #+END_SRC
  
Tem bastante né? Com o tempo a gente vai se acostumando com as
funcionalidades de cada uma. A verdade é que elas é que salvam a
patria qdo vc tiver enroscado com alguma questão específica do seu
projeto. Isso vai acontecer quando vc tiver trabalhando na área...

* gradlew (gradle wrapper)  
   #+NAME gradlew                  
   #+BEGIN_SRC shell :session s1 :results output :exports both
      #starts code
      
   #+END_SRC
  Gradle 5.1.1
  
* Referencias
  tarfileWikiPedia https://pt.wikipedia.org/wiki/Tar_(computa%C3%A7%C3%A3o)
  gradleCodsInitPlugin https://docs.gradle.org/current/userguide/build_init_plugin.html
  http://professorramos.com/index.php/script-bat-2-como-criar-um-menu-em-arquivos-bat/
