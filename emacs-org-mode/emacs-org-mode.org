* Inserindo uma data (timestamp) no documento
  C-c ! (org-time-stamp-inactive) Insere um timestamp que nao gera uma
  entrada na agenda do org-mode
  [2017-01-18 Qua]
* Inserindo uma data do calendário
  C-c <
  <2017-01-19 Qui>

  

* Navegar nas sessões
   C-c p (Navega pra sessão anterior)
   C-c n (Navega pra próxima sessão)

* Abrindo e Fechando sessoes do documento
   O mais comum é alternar abrir e fechar com tab
   As vezes a sessão está extensa, com muitos parágrafos, códigos
   etc... Você quer fechar a sessão mas com tab não dá porque você
   teria que ir até o início da sessão pra poder posicionar o cursos
   pra então dar o tab e fechar a a sessão do dumento. Você queria
   fechar a sessão do documento de qualquer parte que o curso estiver
   dentreo dela... é fácil S-<tab>

* Timer
   C-c C-x . [Inicia timer]
   C-c C-x . [de novo pra inserir vlr do timer]
   pode fazer isso várias vezes
   C-c C-x - [Depois que já usou o timer, isso o desliga]

* Links
** Links Externos
   C-c C-l
   Aparecerá pra você o seguinte...

   Insert a link.
   Use TAB to complete link prefixes, then RET for type-specific completion support

   O seu cursor estará no minibuffer...
   Pode dar um TAB 
   Depois disso o emacs abre outro buffer pra vc conforme abaixo

   Click on a completion to select it.
   In this buffer, type RET to select the completion near point.

   Possible completions are:
   bbdb: 	bibtex: 	docview: 	doi: 	elisp: 	file+emacs:
   file+sys: 	file: 	ftp: 	gnus: 	help: 	http:
   https: 	info: 	irc: 	mailto: 	message: 	mhe:
   news: 	rmail: 	shell:     
   
   Você pode clicar em http, por exemplo...
   Então o minibuffer te pergunta a url, eu coloquei www.google.com
   Após vc digiar a url e dar um enter
   O minibuffer pergunta a descrição do link, eu coloquei: site do google
   Após o Enter, o resultado segue abaixo
   [[http:www.google.com][site do google]]
   Um clike simples do mouse abre o link no navegador.


* Babel (Block Code Vars)
  Usar variáveis bash com blocos de código   

** Blocos de Códigos Babel

Propriedade :output
O valor "replace" (:output replace é o padrão), então não precisa
colocar se não quizer.
O valor "output" significa...
   

** Sintaxe Highlight
#+name: codigo_em_emacs-lisp
#+BEGIN_SRC emacs-lisp  :eval never-exports :output output :export both
;; fontify code in code blocks
(message "mensagem5")
#+END_SRC    

#+RESULTS: codigo_em_emacs-lisp
: mensagem5

** Sintaxe highlight na exportação
   https://github.com/syl20bnr/spacemacs/issues/7055







*** Refs
    http://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang
    http://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html


** Usando variáveis em Blocos de Códigos ShellScript

#+name: var abobe BEGIN_SRC sh works
#+var: Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "")
#+BEGIN_SRC sh :eval never-exports  :results output replace  :exports both
echo $Path #If var were in line with BEGIN_SRC line would work, but above dont
ls -l $($Path) #YES works
#+END_SRC

#+RESULTS:
: 
: total 8
: -rw-rw-r--. 1 wagner wagner  183 Jan  6 00:21 1
: -rw-rw-r--. 1 wagner wagner 1464 Jan  6 00:34 emacs-org-mode.org


#+name: var inline with BEGING_SRC sh
#+BEGIN_SRC sh :eval never-exports :var Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "") :results output replace  :exports both
echo $Path #YES PRINT $Path variable value
ls -l $($Path) #YES list files in $Path 
#+END_SRC

#+RESULTS: var inline with BEGING_SRC sh
: '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/'
: total 8
: -rw-rw-r--. 1 wagner wagner  183 Jan  6 00:21 1
: -rw-rw-r--. 1 wagner wagner 1471 Jan  6 00:35 emacs-org-mode.org




#+name: Must use $($Path) because $Path does not works
#+BEGIN_SRC sh :eval never-exports :var Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "") :results output replace  :exports both
echo $Path #YES PRINT $Path variable value
ls -l $Path 2>&1 #inhibit all possible output
#+END_SRC

#+RESULTS: Must use $($Path) because $Path does not works


Still not can change dir to $Path neither $($Path) but ls $($Path) works
#+name: Changing dir to var  Path value
#+BEGIN_SRC sh :eval never-exports :var Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "") :results output replace  :exports both
echo $Path #YES PRINT $Path variable value

cd  $Path 2>&1 #does not works as showed below

cd $($Path) 2>&1 #does not work as showed below
echo [1] -$(pwd) # print user home directory

p=$Path
cd $p 2>&1 #does not work as showed below
echo [2] -$(pwd) # print user home directory

p=$($Path) 
cd $p 2>&1 #does not work as showed below 
echo [3] -$(pwd) # print user home directory

p="$($Path)" 
cd $p 2>&1 #does not work as showed below 
echo [4] -$(pwd) # print user home directory

p="$($Path)" 
cd "$($Path)" #does not work as showed below 
echo [5] -$(pwd) # print user home directory

export p=$Path 
cd $p #does not work as showed below 
echo [6] -$(pwd) # print user home directory


#+END_SRC

#+RESULTS: Changing dir to var  Path value
: '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/'
: sh: line 7: cd: '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/': Arquivo ou diretÃ³rio nÃ£o encontrado
: [1] -/home/wagner
: sh: line 13: cd: '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/': Arquivo ou diretÃ³rio nÃ£o encontrado
: [2] -/home/wagner
: [3] -/home/wagner
: [4] -/home/wagner
: [5] -/home/wagner
: [6] -/home/wagner













